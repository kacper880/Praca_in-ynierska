Komunikacja datagramowa

	W stosunku do rozwiązania połączenia opartego na komunikacji TCP, komunikacja datagramowa   jest stosunkowo zawodna. Głównym powodem jest brak połączenia między stroną klienta, serwerem oraz mechanizmu  potwierdzającego dostarczenie danej wysłanej paczki danych.  Jedną z ważniejszych cech wyróżniających komunikację opartą na UDP jest brak gniazda serwera.  Zadaniem gniazd datagramowych  jest odbieranie i wysyłanie zdefiniowanych datagramów.  Ważnym elementem, pozwalającym na przeprowadzenie komunikacji jest zastosowanie nagłówka, zawierający informacje o tym jaki port źródłowy zastosować, port docelowy oraz długość datagramu. Blok danych datagramu jest ograniczony do 65507 Bajtów, co odzwierciedla maksymalną długość pakietu IP. 
	Aby przeprowadzić prostą komunikację typu klient-serwer potrzebujemy zaimplementować trzy klasy. Pierwsza z nich, główna wywoła nam dwa wątki, które odpowiednio wywołają dwie inne klasy. Pierwszy wątek dotyczy klasy Serwera, który będzie nasłuchiwał przychodzących wiadomości od strony klienta. W moim przykładzie ustawiłem, że Serwer otworzy się na komunikację przez 100 s. Jednocześnie drugi wątek, obsługujący stronę klienta jest uruchamiany. Nie nakładamy na niego żadnych ograniczeń czasowych.  Po stronie klienta, otwieramy gniazdo za pomocą DatagramSocket. Ustawiamy bufor, którym zostaną wpisane jakieś dane. Następnie implementujemy klasę DatagramPacket. I na końcu za pomocą obiektu klasy DatagramSocket wysyłamy pakiet.  Natomiast Server otwiera port odbiera pakiet i potwierdza stronie klienta, że datagram dotarł.
W drugiej klasie, odzwierciedlającej serwer na początku ustawiamy adres IP urządzenia. Aby ustalić, jaki naprawdę dane urządzenie, emulator ma adres IP należy znaleźć w ustawieniach , zakładka informacje o telefonie. Znajduje się tam m.in. szukany adres IP, adres Bluetooth, czas działania i inne.  W zależności od tego czy źródłem Internetu są pakiety internetowe czy wifi, będziemy posiadali różne IP. Sytuacja ta nie tyczy się wbudowanego w środowisko programistyczne Eclipse IDE wersja Juno Service Release 2 emulatora AVD. Z wielokrotnych badań, wynika że emulator posiada swój własny adres IP 10.0.2.15 i nie zależy on od źródła Internetu. Kolejnym elementem potrzebnym do zainicjowania połączenia jest numer portu. O ile adresy IP urządzeń nie muszą się zgadzać, to numer portu po obu stronach musi być taki sam. Opracowałem metodę, która zwraca nam wszystkie dostępne, wolne porty w sieci. Zakres obsługiwanych portów mieści się w zakresie od 0 do 65535. Nie wszystkie porty z tego zakresu są dostępne dla użytkownika.  Od 0 do 1023 są to porty zarezerwowane na usługi związane z pocztą elektroniczną. Od 1024 do 49151 są ogólnie zarejestrowane, w tym przedziale użytkownik może ustanawiać połączenie. Ostatni zbiór zawiera porty prywatne, niedostępne zwykłemu użytkownikowi. W moim przypadku pierwszy dostępny port był 39704.  Po ustaleniu odpowiedniego portu, musimy zaimplementować klasę, która zwróci nam pod jaki adres będziemy się łączyć.  Tą klasą jest InetAdress, obsługująca wcześniej zdefiniowany adres IP urządzenia. Klasę wywołujemy za pomocą metody getByName()  ,w której jako parametr podajemy wcześniej zadeklarowany string zawierający adres naszego urządzenia. 
	W kolejnych rozdziałach dowiemy się na jakiej zasadzie działa klasa DatagramPackiet, służąca do transportowania, wysyłania pewnej porcji danych od strony klienta po stronę serwera. Wysyłając paczkę musimy ją także odebrać. Nieoceniona tu będzie klasa DatagramSocket otwierająca komunikację między dwoma aplikacjami.   Następnie zaznajomimy się jak wygląda ostatecznie komunikacja,  przyglądając się szczegółowym opisom dwóch klas serwera i klienta.

